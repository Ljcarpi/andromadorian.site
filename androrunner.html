<!DOCTYPE html>
<html lang="es" class="dark">
<head>
  <meta charset="UTF-8" />
  <title>Andro Runner – Neon Skies</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

    :root {
      --violet: #d187e8;
      --violet-2: #e887e2;
      --blue: #87c9e8;
      --teal: #e8e287;
      --teal-2: #f5f0ab;

      --bg-main: radial-gradient(circle at top, #0b1120 0, #020617 60%);
      --panel: rgba(15, 23, 42, 0.98);
      --accent: #06b6d4;
      --accent-2: #6366f1;
      --accent-3: #f97316;
      --danger: #ef4444;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }

    html, body {
      height: 100%;
    }

    html.dark {
      color-scheme: dark;
    }

    html:not(.dark) body {
      color: #0f172a;
    }

    html.dark body {
      color: #e5e7eb;
    }

    body {
      min-height: 100vh;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    .blurred-gradient-bg {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      filter: blur(30px) saturate(110%);
      transform: translateZ(0);
    }

    .dark .blurred-gradient-bg {
      background:
        radial-gradient(60% 60% at 20% 0%, #7c2aa6 0%, transparent 60%),
        radial-gradient(70% 70% at 85% 10%, #165e57 0%, transparent 60%),
        radial-gradient(65% 65% at 15% 90%, #9b2fc7 0%, transparent 60%),
        radial-gradient(80% 80% at 80% 85%, #2a427a 0%, transparent 60%),
        radial-gradient(120% 120% at 50% 30%, rgba(0, 0, 0, .25) 0%, rgba(0, 0, 0, 0) 60%);
    }

    .blurred-gradient-bg:not(.dark-bg) {
      background:
        radial-gradient(60% 60% at 20% 0%, var(--teal-2) 0%, transparent 60%),
        radial-gradient(70% 70% at 85% 10%, var(--violet-2) 0%, transparent 60%),
        radial-gradient(65% 65% at 15% 90%, var(--violet) 0%, transparent 60%),
        radial-gradient(80% 80% at 80% 85%, var(--blue) 0%, transparent 60%),
        radial-gradient(120% 120% at 50% 30%, rgba(255, 255, 255, .25) 0%, rgba(255, 255, 255, 0) 60%);
    }

    .app {
      width: 100%;
      max-width: 1400px;
      padding: 12px;
    }

    /* Barra superior de navegación */
    .top-nav {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .top-nav a {
      text-decoration: none;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      transition:
        background 0.15s ease,
        color 0.15s ease,
        box-shadow 0.15s ease,
        transform 0.1s ease;
    }

    .top-nav a:hover {
      background: radial-gradient(circle, rgba(129, 140, 248, 0.16), transparent 70%);
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.9);
      transform: translateY(-1px);
    }

    .view {
      display: none;
      background: radial-gradient(circle at top, #020617 0, #020617 55%, #020617 100%);
      border-radius: 22px;
      box-shadow: 0 22px 60px rgba(0, 0, 0, 0.95);
      padding: 18px 14px 16px;
      min-height: min(96vh, 780px);
      position: relative;
      overflow: hidden;
      background-color: rgba(10, 12, 20, 0.94);
      border: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
    }

    .view.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .view-header {
      text-align: center;
      margin-bottom: 18px;
    }

    .view-header h1 {
      font-size: 2.1rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #f97316;
      text-shadow:
        0 0 10px rgba(249, 115, 22, 0.9),
        0 0 28px rgba(56, 189, 248, 0.6);
      margin-bottom: 4px;
    }

    .view-header p {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .card {
      background: radial-gradient(circle at top, #0b1120 0, #020617 52%, #020617 100%);
      border-radius: 20px;
      padding: 18px 16px 14px;
      max-width: 520px;
      width: 100%;
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.9);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -140px;
      background:
        radial-gradient(circle at top left, rgba(56, 189, 248, 0.16), transparent 60%),
        radial-gradient(circle at bottom right, rgba(236, 72, 153, 0.16), transparent 60%);
      pointer-events: none;
      opacity: 0.9;
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    .section {
      padding: 8px 0;
    }

    .section + .section {
      border-top: 1px dashed rgba(148, 163, 184, 0.4);
      margin-top: 9px;
    }

    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
      margin-bottom: 7px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 0.98rem;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.07em;
      text-transform: uppercase;
      width: 100%;
      background: linear-gradient(135deg, #22c55e, #a3e635);
      color: #022c22;
      box-shadow: 0 10px 24px rgba(34, 197, 94, 0.65);
      transition:
        transform 0.12s ease,
        box-shadow 0.12s ease,
        filter 0.12s ease;
    }

    .btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 14px 30px rgba(34, 197, 94, 0.78);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 7px 18px rgba(34, 197, 94, 0.6);
    }

    .btn-ghost {
      background: transparent;
      color: var(--accent-2);
      border: 1px solid rgba(129, 140, 248, 0.9);
      box-shadow: none;
    }

    .btn-ghost:hover {
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.9);
      background: radial-gradient(circle, rgba(129, 140, 248, 0.16), transparent 70%);
    }

    .btn-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
    }

    .diff-toggle {
      display: flex;
      gap: 6px;
      padding: 3px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.6);
    }

    .diff-btn {
      flex: 1;
      border-radius: 999px;
      border: none;
      font-size: 0.75rem;
      padding: 5px 0;
      cursor: pointer;
      background: transparent;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-weight: 600;
      transition:
        background 0.15s ease,
        color 0.15s ease,
        box-shadow 0.15s ease;
    }

    .diff-btn.active {
      background: linear-gradient(135deg, #6366f1, #22c55e);
      color: #020617;
      box-shadow: 0 4px 12px rgba(129, 140, 248, 0.75);
    }

    .skin-grid {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .skin-option {
      border-radius: 12px;
      padding: 4px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.9);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
      min-width: 70px;
      transition:
        border-color 0.15s ease,
        box-shadow 0.15s ease,
        transform 0.12s ease,
        background 0.15s ease;
    }

    .skin-option:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.7);
    }

    .skin-option.active {
      border-color: #f97316;
      box-shadow: 0 0 16px rgba(249, 115, 22, 0.7);
      background: radial-gradient(circle, rgba(249, 115, 22, 0.16), rgba(15, 23, 42, 0.95));
    }

    .skin-preview {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      overflow: hidden;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .skin-preview img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .skin-label {
      font-size: 0.72rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .hint {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 6px;
    }

    .kbd {
      display: inline-block;
      padding: 1px 5px;
      border-radius: 4px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.8);
      font-size: 0.75rem;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
        Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    #viewInstructions .card {
      max-width: 760px;
    }

    .instructions-grid {
      display: grid;
      gap: 10px;
      font-size: 0.9rem;
    }

    @media (min-width: 820px) {
      .instructions-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .instructions-grid h3 {
      font-size: 0.9rem;
      margin-bottom: 3px;
      color: var(--accent-2);
    }

    ul {
      list-style: disc;
      padding-left: 16px;
      color: var(--muted);
    }

    ul li + li {
      margin-top: 3px;
    }

    .footer-row {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    #viewGame {
      align-items: stretch;
      justify-content: flex-start;
      padding: 12px 10px 14px;
      gap: 8px;
    }

    .hud-bar {
      width: 100%;
      max-width: 1320px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      padding: 6px 9px;
      border-radius: 999px;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), #020617);
      border: 1px solid rgba(148, 163, 184, 0.5);
    }

    .hud-left,
    .hud-right {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .pill {
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(15, 23, 42, 0.9);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .pill strong {
      color: var(--accent-2);
    }

    .pill-score {
      background: linear-gradient(135deg, #22c55e, #a3e635);
      color: #022c22;
      box-shadow: 0 0 18px rgba(34, 197, 94, 0.75);
    }

    .pill-score strong {
      color: #022c22;
    }

    .indicator-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.8);
    }

    #gameCanvas {
      margin: 8px auto 0;
      display: block;
      background: #020617;
      width: 100%;
      max-width: 1320px;
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 22px 52px rgba(0, 0, 0, 0.95);
    }

    .touch-hint {
      margin: 6px auto 0;
      text-align: center;
      font-size: 0.78rem;
      color: var(--muted);
    }

    #viewGameOver .card {
      max-width: 440px;
      background: radial-gradient(circle at top, #0f172a 0, #020617 70%);
    }

    .go-title {
      font-size: 1.4rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--danger);
      text-shadow: 0 0 12px rgba(239, 68, 68, 0.9);
      margin-bottom: 2px;
      text-align: center;
    }

    .go-sub {
      font-size: 0.86rem;
      color: var(--muted);
      text-align: center;
      margin-bottom: 10px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.86rem;
      padding: 2px 0;
      color: var(--muted);
    }

    .stat-row strong {
      color: var(--accent-2);
    }

    .go-tip {
      font-size: 0.76rem;
      text-align: center;
      margin-top: 8px;
      color: var(--muted);
    }

    @media (max-width: 840px) {
      .view {
        padding: 14px 10px 10px;
        min-height: 90vh;
        border-radius: 18px;
      }

      .view-header h1 {
        font-size: 1.6rem;
      }

      .hud-bar {
        flex-direction: column;
        align-items: flex-start;
        border-radius: 16px;
      }

      .hud-right {
        justify-content: flex-end;
        width: 100%;
      }
    }

    @media (max-width: 640px) {
      .app {
        padding: 10px 8px;
      }

      #gameCanvas {
        border-radius: 16px;
      }

      .card {
        border-radius: 18px;
      }
    }
  </style>
</head>
<body>
  <div class="blurred-gradient-bg" aria-hidden="true"></div>

  <div class="app">
    <div class="top-nav">
      <a href="https://andromadorian.site/juegos">Volver al menú de juegos</a>
      <a href="https://andromadorian.site">Volver al sitio principal</a>
    </div>

    <!-- MAIN MENU -->
    <section id="viewMenu" class="view active">
      <div class="view-header">
        <h1>ANDRO RUNNER</h1>
        <p>Triple-jump skies, sliding islands and swappable neon heads.</p>
      </div>

      <div class="card">
        <div class="card-inner">
          <div class="section">
            <div class="section-title">Difficulty</div>
            <div class="diff-toggle" id="diffToggle">
              <button class="diff-btn" data-mode="easy">Easy</button>
              <button class="diff-btn active" data-mode="normal">Normal</button>
              <button class="diff-btn" data-mode="hard">Hard</button>
            </div>
            <p class="hint">
              Higher difficulty = faster world and denser obstacle waves (which ramp over time).
            </p>
          </div>

          <div class="section">
            <div class="section-title">Skin (Head)</div>
            <div class="skin-grid" id="skinGrid">
              <div class="skin-option active" data-skin="face1.png">
                <div class="skin-preview">
                  <img src="assets/faces/face1.png" alt="Skin 1" />
                </div>
                <div class="skin-label">Skin 1</div>
              </div>
              <div class="skin-option" data-skin="face2.png">
                <div class="skin-preview">
                  <img src="assets/faces/face2.png" alt="Skin 2" />
                </div>
                <div class="skin-label">Skin 2</div>
              </div>
              <div class="skin-option" data-skin="face3.png">
                <div class="skin-preview">
                  <img src="assets/faces/face3.png" alt="Skin 3" />
                </div>
                <div class="skin-label">Skin 3</div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-title">Play</div>
            <div class="btn-row">
              <button id="btnPlay" class="btn">Start Run</button>
              <button id="btnInstructions" class="btn btn-ghost">How to Play</button>
            </div>
          </div>

          <div class="section">
            <div class="section-title">Controls</div>
            <p class="hint">
              Desktop: <span class="kbd">Space</span> = jump (up to 3 jumps),
              <span class="kbd">Shift</span> = drop through platform.<br />
              Mobile: tap on the game area to jump.
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- INSTRUCTIONS -->
    <section id="viewInstructions" class="view">
      <div class="view-header">
        <h1>How to Play</h1>
        <p>Jump between floating lanes, stomp hazards, collect orbs and keep your head intact.</p>
      </div>

      <div class="card">
        <div class="card-inner">
          <div class="instructions-grid">
            <div>
              <h3>Movement</h3>
              <ul>
                <li>Your runner auto-moves to the right.</li>
                <li>Press <span class="kbd">Space</span> or tap to jump.</li>
                <li>You can chain up to <strong>3 jumps</strong> mid-air by default.</li>
                <li>Landing on ground or platforms restores all jumps.</li>
                <li>Stomping an obstacle from above restores jumps and destroys it.</li>
                <li>Press <span class="kbd">Shift</span> while on a platform to drop through it.</li>
                <li>There's a ceiling: you cannot go above it, but you won't lose by touching it.</li>
              </ul>
            </div>

            <div>
              <h3>Obstacles</h3>
              <ul>
                <li>Neon shards and blocks appear on the ground, mid-air and near the ceiling.</li>
                <li>Most hazards sway horizontally for trickier timing.</li>
                <li>Touching a hazard from the side or below = instant defeat (unless shielded).</li>
                <li>Spawn frequency increases over time on every difficulty.</li>
              </ul>
            </div>

            <div>
              <h3>Power-ups</h3>
              <ul>
                <li><strong>Shield</strong>: survives one hit and turns it into a smash.</li>
                <li><strong>Jump Boost</strong>: temporarily increases max jumps.</li>
                <li><strong>Score Burst</strong>: instantly adds bonus score.</li>
                <li><strong>Slow Time</strong>: slows world speed for a while.</li>
                <li>Run through power-ups to grab them.</li>
              </ul>
            </div>

            <div>
              <h3>Score</h3>
              <ul>
                <li><strong>+1</strong> point every second you survive.</li>
                <li><strong>+1</strong> point per obstacle destroyed.</li>
                <li>Some power-ups add extra score.</li>
                <li>Live score is shown in the HUD at the top.</li>
              </ul>
            </div>

            <div>
              <h3>Platforms &amp; Levels</h3>
              <ul>
                <li>Three vertical lanes of floating platforms, each with gaps.</li>
                <li>Use upper floors to route around dense waves of hazards.</li>
                <li>World themes shift as time passes (sky, colors and silhouettes change).</li>
              </ul>
            </div>

            <div>
              <h3>Difficulty &amp; Skins</h3>
              <ul>
                <li>Select Easy / Normal / Hard for speed + spawn tuning.</li>
                <li>Choose your head skin in the main menu. It is drawn as a large PNG sprite.</li>
                <li>Music plays only during the actual run, never in menus or after defeat.</li>
              </ul>
            </div>
          </div>

          <div class="footer-row">
            <button id="btnBackMenu" class="btn btn-ghost">Back to Menu</button>
            <button id="btnPlayFromInstructions" class="btn">Start Run</button>
          </div>
        </div>
      </div>
    </section>

    <!-- GAME -->
    <section id="viewGame" class="view">
      <div class="hud-bar">
        <div class="hud-left">
          <div class="pill pill-score">
            SCORE:<strong id="scoreText">0</strong>
          </div>
          <div class="pill">
            LEVEL:<strong id="levelText">1 – Dawn City</strong>
          </div>
          <div class="pill">
            MODE:<strong id="modeText">Normal</strong>
          </div>
          <div class="pill">
            SHIELD:<strong id="shieldText">Off</strong>
          </div>
          <div class="pill">
            JUMP BOOST:<strong id="jumpBoostText">-</strong>
          </div>
          <div class="pill">
            BONUS:<strong id="bonusText">0</strong>
          </div>
          <div class="pill">
            SLOW:<strong id="slowText">Off</strong>
          </div>
        </div>
        <div class="hud-right">
          <span class="indicator-dot"></span>
          <span style="font-size: 0.75rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.12em;">
            RUNNING
          </span>
        </div>
      </div>

      <!-- Menor resolución interna para mejor rendimiento -->
      <canvas id="gameCanvas" width="960" height="540"></canvas>
      <p class="touch-hint">
        Space / tap = jump (up to 3 default jumps). Shift = drop down from platforms.<br />
        Stomp from above to crush hazards and refill jumps.
      </p>
    </section>

    <!-- GAME OVER -->
    <section id="viewGameOver" class="view">
      <div class="card">
        <div class="card-inner">
          <div class="go-title">RUN ENDED</div>
          <p class="go-sub">
            Press <strong>Restart</strong> or hit <span class="kbd">Space</span> to launch a new run.
          </p>

          <div class="stat-row">
            <span>Final Score</span>
            <strong id="finalScoreText">0</strong>
          </div>
          <div class="stat-row">
            <span>Best (session)</span>
            <strong id="bestScoreText">0</strong>
          </div>
          <div class="stat-row">
            <span>Obstacles Destroyed</span>
            <strong id="destroyedText">0</strong>
          </div>
          <div class="stat-row">
            <span>Time Survived</span>
            <strong id="timeText">0 s</strong>
          </div>

          <div class="btn-row" style="margin-top: 10px;">
            <button id="btnRestart" class="btn">Restart</button>
            <button id="btnGoMenu" class="btn btn-ghost">Main Menu</button>
          </div>

          <p class="go-tip">
            Tip: Ride upper lanes, drop down with Shift and chain stomps to keep your triple jump alive.
          </p>
        </div>
      </div>
    </section>
  </div>

  <script>
    const bgMusic = new Audio("assets/audio/game-start.mp3");
    bgMusic.loop = true;

    let audioCtx = null;

    function ensureAudioContext() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return;
        audioCtx = new AC();
      }
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
      }
    }

    function playMusic() {
      try {
        ensureAudioContext();
        bgMusic.currentTime = 0;
        bgMusic.play().catch(() => {});
      } catch (_) {}
    }

    function stopMusic() {
      try {
        bgMusic.pause();
      } catch (_) {}
    }

    function playBeep(type) {
      try {
        ensureAudioContext();
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        let freq = 440;
        let dur = 0.08;

        switch (type) {
          case "jump":
            freq = 880;
            dur = 0.06;
            break;
          case "stomp":
            freq = 240;
            dur = 0.11;
            break;
          case "hit":
            freq = 130;
            dur = 0.16;
            break;
          case "power":
            freq = 1020;
            dur = 0.12;
            break;
        }

        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.24, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(
          0.001,
          audioCtx.currentTime + dur
        );
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
      } catch (_) {}
    }

    const views = {
      menu: document.getElementById("viewMenu"),
      instructions: document.getElementById("viewInstructions"),
      game: document.getElementById("viewGame"),
      gameOver: document.getElementById("viewGameOver"),
    };
    let currentView = "menu";

    function showView(id) {
      Object.values(views).forEach((v) => v.classList.remove("active"));
      views[id].classList.add("active");
      currentView = id;
    }

    const diffToggle = document.getElementById("diffToggle");
    const diffButtons = diffToggle.querySelectorAll(".diff-btn");
    const modeText = document.getElementById("modeText");

    let difficulty = "normal";

    // Velocidades y spawn ligeramente ajustados y con límite de objetos para mejorar rendimiento
    const difficultySettings = {
      easy:  { speed: 380, minSpawn: 0.55, maxSpawn: 0.8 },
      normal:{ speed: 500, minSpawn: 0.4,  maxSpawn: 0.6 },
      hard:  { speed: 620, minSpawn: 0.3,  maxSpawn: 0.5 },
    };

    diffButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        diffButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        difficulty = btn.dataset.mode;
        modeText.textContent =
          difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
      });
    });

    const skinGrid = document.getElementById("skinGrid");
    const skinOptions = skinGrid.querySelectorAll(".skin-option");
    let selectedSkinFile = "face1.png";

    const faceImg = new Image();
    faceImg.src = "assets/faces/" + selectedSkinFile;

    skinOptions.forEach((opt) => {
      opt.addEventListener("click", () => {
        skinOptions.forEach((o) => o.classList.remove("active"));
        opt.classList.add("active");
        selectedSkinFile = opt.getAttribute("data-skin") || "face1.png";
        faceImg.src = "assets/faces/" + selectedSkinFile;
      });
    });

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const WORLD_WIDTH = canvas.width;
    const WORLD_HEIGHT = canvas.height;

    const GROUND_HEIGHT = 110;
    const GROUND_Y = WORLD_HEIGHT - GROUND_HEIGHT;
    const CEILING_Y = 40; // se mantiene, pero bajamos el 3er piso

    const GRAVITY = 2200;
    const JUMP_FORCE = 800;
    const BASE_MAX_JUMPS = 3;
    const LEVEL_DURATION = 26;

    const PLATFORM_LENGTH = 260;
    const PLATFORM_GAP = 200;
    const PLATFORM_BANDS = 3;

    const scoreText = document.getElementById("scoreText");
    const levelText = document.getElementById("levelText");
    const shieldText = document.getElementById("shieldText");
    const jumpBoostText = document.getElementById("jumpBoostText");
    const bonusText = document.getElementById("bonusText");
    const slowText = document.getElementById("slowText");

    const finalScoreText = document.getElementById("finalScoreText");
    const bestScoreText = document.getElementById("bestScoreText");
    const destroyedText = document.getElementById("destroyedText");
    const timeText = document.getElementById("timeText");

    let isRunning = false;
    let lastTime = 0;

    let player;
    let obstacles = [];
    let powerups = [];
    let platforms = [];

    let survivalTime = 0;
    let obstaclesDestroyed = 0;
    let bonusScore = 0;
    let bestScore = 0;

    let obstacleTimer = 0;
    let nextObstacleSpawn = 1;

    let powerTimer = 0;
    let nextPowerSpawn = 8;

    let currentLevel = 0;

    let maxJumps = BASE_MAX_JUMPS;
    let shieldActive = false;
    let jumpBoostTime = 0;
    let slowTime = 0;
    let speedFactor = 1;

    let runAnimTime = 0;
    let dropRequested = false;

    const themes = [
      {
        name: "Dawn City",
        skyTop: "#0ea5e9",
        skyBottom: "#020617",
        glow: "#fde047",
        ground: "#16a34a",
      },
      {
        name: "Solar Desert",
        skyTop: "#fb923c",
        skyBottom: "#7c2d12",
        glow: "#facc15",
        ground: "#ca8a04",
      },
      {
        name: "Night Peaks",
        skyTop: "#1e293b",
        skyBottom: "#020617",
        glow: "#a855f7",
        ground: "#16a34a",
      },
    ];

    let currentTheme = themes[0];

    function applyTheme() {
      currentTheme = themes[currentLevel % themes.length];
      levelText.textContent = `${currentLevel + 1} – ${currentTheme.name}`;
    }

    function initPlatforms() {
      platforms = [];

      // Bajamos un poco el tercer piso (más cerca del piso) para ampliar espacio con el techo
      const bands = [
        { y: GROUND_Y - 130, offset: 120 },
        { y: GROUND_Y - 250, offset: 350 },
        { y: GROUND_Y - 320, offset: 610 }, // antes -370, ahora más abajo
      ];

      bands.forEach((band, index) => {
        // 2 plataformas en lugar de 3 para reducir objetos y mejorar rendimiento
        for (let i = 0; i < 2; i++) {
          platforms.push({
            x: band.offset + i * (PLATFORM_LENGTH + PLATFORM_GAP),
            y: band.y,
            w: PLATFORM_LENGTH,
            h: 20,
            band: index,
          });
        }
      });
    }

    function rand(min, max) {
      return min + Math.random() * (max - min);
    }

    function obstacleSpawnWindow() {
      const cfg = difficultySettings[difficulty];
      const progress = Math.min(1, survivalTime / 60);
      const factor = 1 - 0.65 * progress;
      return {
        min: cfg.minSpawn * factor,
        max: cfg.maxSpawn * factor,
      };
    }

    function resetGameState() {
      currentTheme = themes[0];

      // Solo cabeza
      player = {
        w: 40,
        h: 40,
        x: WORLD_WIDTH * 0.16,
        y: GROUND_Y - 40,
        vy: 0,
        jumpsUsed: 0,
      };

      initPlatforms();

      obstacles = [];
      powerups = [];

      survivalTime = 0;
      obstaclesDestroyed = 0;
      bonusScore = 0;

      obstacleTimer = 0;
      powerTimer = 0;
      const windowSpawn = obstacleSpawnWindow();
      nextObstacleSpawn = rand(windowSpawn.min, windowSpawn.max);
      nextPowerSpawn = rand(6, 11);

      currentLevel = 0;
      maxJumps = BASE_MAX_JUMPS;
      shieldActive = false;
      jumpBoostTime = 0;
      slowTime = 0;
      speedFactor = 1;
      applyTheme();
      updateScoreHUD();
      updatePowerHUD();
      runAnimTime = 0;
      dropRequested = false;

      faceImg.src = "assets/faces/" + selectedSkinFile;
    }

    function spawnObstacle() {
      const typeRoll = Math.random();

      let w, h;
      if (typeRoll < 0.4) {
        w = 30;
        h = 36;
      } else if (typeRoll < 0.75) {
        w = 38;
        h = 52;
      } else {
        w = 48;
        h = 28;
      }

      const verticalRoll = Math.random();
      let y;
      let vType;
      if (verticalRoll < 0.45) {
        y = GROUND_Y - h;
        vType = "ground";
      } else if (verticalRoll < 0.8) {
        const minY = GROUND_Y - h - 240;
        const maxY = GROUND_Y - h - 110;
        y = rand(Math.max(70, minY), Math.max(100, maxY));
        vType = "mid";
      } else {
        y = rand(50, 180);
        vType = "ceiling";
      }

      let shape = "box";
      const shapeRoll = Math.random();
      if (shapeRoll < 0.5) shape = "box";
      else if (shapeRoll < 0.8) shape = "circle";
      else shape = "spike";

      let moveType = "static";
      let amplitude = 0;
      let moveSpeed = 0;
      let phase = 0;
      const moveRoll = Math.random();
      if (moveRoll < 0.55) {
        moveType = "hmove";
        amplitude = rand(28, 60);
        moveSpeed = rand(5, 10);
        phase = Math.random() * Math.PI * 2;
      }

      const baseX = WORLD_WIDTH + w;

      obstacles.push({
        baseX,
        x: baseX,
        y,
        w,
        h,
        shape,
        vType,
        moveType,
        amplitude,
        moveSpeed,
        phase,
        offsetX: 0,
      });

      const windowSpawn = obstacleSpawnWindow();
      nextObstacleSpawn = rand(windowSpawn.min, windowSpawn.max);

      // Límite más bajo para no acumular demasiados obstáculos
      if (obstacles.length > 30) {
        obstacles.splice(0, obstacles.length - 30);
      }
    }

    function spawnPowerup() {
      const kinds = ["shield", "jump", "score", "slow"];
      const kind = kinds[Math.floor(Math.random() * kinds.length)];

      const y = rand(100, GROUND_Y - 160);

      powerups.push({
        x: WORLD_WIDTH + 30,
        y,
        r: 16,
        kind,
      });

      nextPowerSpawn = rand(6, 11);

      if (powerups.length > 10) {
        powerups.splice(0, powerups.length - 10);
      }
    }

    function liveScore() {
      return Math.floor(survivalTime) + obstaclesDestroyed + bonusScore;
    }

    function updateScoreHUD() {
      scoreText.textContent = liveScore();
    }

    function updatePowerHUD() {
      shieldText.textContent = shieldActive ? "On" : "Off";
      jumpBoostText.textContent =
        jumpBoostTime > 0 ? `${maxJumps} jumps (${jumpBoostTime.toFixed(1)}s)` : "-";
      bonusText.textContent = bonusScore;
      slowText.textContent = slowTime > 0 ? "On" : "Off";
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function playerRect() {
      return {
        x: player.x,
        y: player.y,
        w: player.w,
        h: player.h,
      };
    }

    function applyPowerup(p) {
      switch (p.kind) {
        case "shield":
          shieldActive = true;
          playBeep("power");
          break;
        case "jump":
          maxJumps = BASE_MAX_JUMPS + 1;
          jumpBoostTime = 10;
          playBeep("power");
          break;
        case "score":
          bonusScore += 10;
          playBeep("power");
          break;
        case "slow":
          slowTime = 6;
          playBeep("power");
          break;
      }
      updatePowerHUD();
    }

    function crushObstacle(oIdx) {
      obstacles.splice(oIdx, 1);
      obstaclesDestroyed++;
      bonusScore++;
      updateScoreHUD();
      playBeep("stomp");
    }

    function handleHit() {
      if (shieldActive) {
        shieldActive = false;
        updatePowerHUD();
        playBeep("stomp");
        return;
      }
      playBeep("hit");
      endGame();
    }

    function updateGame(dt) {
      const targetSpeed = difficultySettings[difficulty].speed;
      speedFactor = 1;
      if (slowTime > 0) {
        slowTime -= dt;
        if (slowTime < 0) slowTime = 0;
        speedFactor = 0.55;
      }

      const worldSpeed = targetSpeed * speedFactor;

      survivalTime += dt;
      updateScoreHUD();

      const newLevel = Math.floor(survivalTime / LEVEL_DURATION);
      if (newLevel !== currentLevel) {
        currentLevel = newLevel;
        applyTheme();
      }

      if (jumpBoostTime > 0) {
        jumpBoostTime -= dt;
        if (jumpBoostTime <= 0) {
          jumpBoostTime = 0;
          maxJumps = BASE_MAX_JUMPS;
        }
        updatePowerHUD();
      }

      // Plataformas
      platforms.forEach((pl) => {
        pl.x -= worldSpeed * dt;
      });
      platforms = platforms.filter((pl) => pl.x + pl.w > -60);

      // Misma configuración de bandas que en initPlatforms (incluyendo 3er piso más bajo)
      const bands = [
        { y: GROUND_Y - 130, offset: 120 },
        { y: GROUND_Y - 250, offset: 350 },
        { y: GROUND_Y - 320, offset: 610 },
      ];
      for (let b = 0; b < PLATFORM_BANDS; b++) {
        const bandPlatforms = platforms.filter((pl) => pl.band === b);
        if (bandPlatforms.length < 2) {
          const lastX =
            bandPlatforms.length > 0
              ? Math.max(...bandPlatforms.map((pl) => pl.x + pl.w))
              : bands[b].offset;
          platforms.push({
            x: lastX + PLATFORM_GAP,
            y: bands[b].y,
            w: PLATFORM_LENGTH,
            h: 20,
            band: b,
          });
        }
      }

      // Obstáculos
      obstacleTimer += dt;
      if (obstacleTimer >= nextObstacleSpawn) {
        obstacleTimer = 0;
        spawnObstacle();
      }

      // Powerups
      powerTimer += dt;
      if (powerTimer >= nextPowerSpawn) {
        powerTimer = 0;
        spawnPowerup();
      }

      // Física del jugador
      player.vy += GRAVITY * dt;
      let newY = player.y + player.vy * dt;

      let onPlatform = false;
      const feetY = newY + player.h;
      for (const pl of platforms) {
        if (
          player.x + player.w * 0.4 > pl.x &&
          player.x + player.w * 0.6 < pl.x + pl.w
        ) {
          if (
            feetY >= pl.y - 4 &&
            player.y + player.h <= pl.y + 10 &&
            !dropRequested
          ) {
            newY = pl.y - player.h;
            player.vy = 0;
            player.jumpsUsed = 0;
            onPlatform = true;
            break;
          }
        }
      }
      dropRequested = false;

      if (!onPlatform) {
        if (feetY >= GROUND_Y) {
          newY = GROUND_Y - player.h;
          player.vy = 0;
          player.jumpsUsed = 0;
        }
      }

      if (newY < CEILING_Y) {
        newY = CEILING_Y;
        if (player.vy < 0) player.vy = 0;
      }

      player.y = newY;

      // Movimiento de obstáculos y powerups
      obstacles.forEach((o) => {
        o.baseX -= worldSpeed * dt;
        if (o.moveType === "hmove") {
          o.offsetX = Math.sin(runAnimTime * o.moveSpeed + o.phase) * o.amplitude;
        } else {
          o.offsetX = 0;
        }
        o.x = o.baseX + o.offsetX;
      });

      powerups.forEach((p) => {
        p.x -= worldSpeed * dt;
      });

      const pRectNow = playerRect();

      // Colisiones con powerups
      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        const puRect = {
          x: p.x - p.r,
          y: p.y - p.r,
          w: p.r * 2,
          h: p.r * 2,
        };
        if (rectsOverlap(pRectNow, puRect)) {
          applyPowerup(p);
          powerups.splice(i, 1);
        }
      }

      // Colisiones con obstáculos
      let collided = false;
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        const oRect = {
          x: o.x,
          y: o.y,
          w: o.w,
          h: o.h,
        };

        if (rectsOverlap(pRectNow, oRect)) {
          const playerBottom = pRectNow.y + pRectNow.h;
          const obstacleTop = oRect.y;

          if (player.vy > 0 && playerBottom - obstacleTop < 18) {
            crushObstacle(i);
            player.vy = -JUMP_FORCE * 0.7;
            player.jumpsUsed = 0;
          } else {
            collided = true;
            break;
          }
        }
      }

      if (collided) {
        handleHit();
        return;
      }

      obstacles = obstacles.filter((o) => o.x + o.w > -80);
      powerups = powerups.filter((p) => p.x + p.r > -80);

      runAnimTime += dt;
    }

    function drawBackground(ctx) {
      const theme = currentTheme;

      const grad = ctx.createLinearGradient(0, 0, 0, WORLD_HEIGHT);
      grad.addColorStop(0, theme.skyTop);
      grad.addColorStop(1, theme.skyBottom);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = theme.glow;
      ctx.beginPath();
      ctx.arc(WORLD_WIDTH * 0.22, WORLD_HEIGHT * 0.22, 70, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Piso bien marcado
      ctx.save();
      ctx.fillStyle = "#111827";
      ctx.fillRect(0, GROUND_Y, WORLD_WIDTH, GROUND_HEIGHT);
      ctx.strokeStyle = "#22c55e";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(WORLD_WIDTH, GROUND_Y);
      ctx.stroke();
      ctx.restore();
    }

    function drawPlatforms(ctx) {
      ctx.save();
      ctx.fillStyle = "#0f172a";
      ctx.strokeStyle = "#22c55e";
      ctx.lineWidth = 2;

      platforms.forEach((pl) => {
        ctx.fillRect(pl.x, pl.y, pl.w, pl.h);
        ctx.strokeRect(pl.x, pl.y, pl.w, pl.h);
      });

      ctx.restore();
    }

    function drawObstacles(ctx) {
      obstacles.forEach((o) => {
        ctx.save();

        if (o.shape === "box") {
          ctx.fillStyle = "#f97316";
          ctx.fillRect(o.x, o.y, o.w, o.h);
        } else if (o.shape === "circle") {
          ctx.fillStyle = "#22d3ee";
          ctx.beginPath();
          ctx.arc(o.x + o.w / 2, o.y + o.h / 2, o.w / 2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillStyle = "#eab308";
          ctx.beginPath();
          ctx.moveTo(o.x, o.y + o.h);
          ctx.lineTo(o.x + o.w / 2, o.y);
          ctx.lineTo(o.x + o.w, o.y + o.h);
          ctx.closePath();
          ctx.fill();
        }

        ctx.restore();
      });
    }

    function drawPowerups(ctx) {
      powerups.forEach((p) => {
        ctx.save();
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        let color = "#22c55e";
        if (p.kind === "shield") color = "#22c55e";
        else if (p.kind === "jump") color = "#3b82f6";
        else if (p.kind === "score") color = "#f97316";
        else if (p.kind === "slow") color = "#a855f7";
        ctx.fillStyle = color;
        ctx.fill();
        ctx.restore();
      });
    }

    function drawPlayer(ctx) {
      ctx.save();

      const headSize = 60;
      const headX = player.x - 10;
      const headY = player.y - 10;

      if (faceImg.complete && faceImg.naturalWidth > 0) {
        ctx.drawImage(faceImg, headX, headY, headSize, headSize);
      } else {
        ctx.fillStyle = "#e5e7eb";
        ctx.beginPath();
        ctx.arc(headX + headSize / 2, headY + headSize / 2, headSize / 2, 0, Math.PI * 2);
        ctx.fill();
      }

      if (shieldActive) {
        ctx.strokeStyle = "#22c55e";
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(
          headX + headSize / 2,
          headY + headSize / 2,
          headSize * 0.75,
          0,
          Math.PI * 2
        );
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      ctx.restore();
    }

    function drawGame() {
      ctx.clearRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
      drawBackground(ctx);
      drawPlatforms(ctx);
      drawObstacles(ctx);
      drawPowerups(ctx);
      drawPlayer(ctx);
    }

    function loop(timestamp) {
      if (!isRunning) return;
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      updateGame(dt);
      drawGame();

      if (isRunning) {
        requestAnimationFrame(loop);
      }
    }

    function startGame() {
      resetGameState();
      showView("game");
      isRunning = true;
      lastTime = 0;
      playMusic();
      requestAnimationFrame(loop);
    }

    function endGame() {
      isRunning = false;
      stopMusic();
      const score = liveScore();
      if (score > bestScore) bestScore = score;

      finalScoreText.textContent = score;
      bestScoreText.textContent = bestScore;
      destroyedText.textContent = obstaclesDestroyed;
      timeText.textContent = `${Math.floor(survivalTime)} s`;

      showView("gameOver");
    }

    function tryJump() {
      if (!isRunning) return;
      if (player.jumpsUsed < maxJumps) {
        player.vy = -JUMP_FORCE;
        player.jumpsUsed++;
        playBeep("jump");
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        if (currentView === "game" && isRunning) {
          tryJump();
        } else if (currentView === "gameOver" && !isRunning) {
          startGame();
        }
      } else if (e.key === "Shift" || e.code === "ShiftLeft" || e.code === "ShiftRight") {
        if (currentView === "game" && isRunning) {
          dropRequested = true;
        }
      }
    });

    function addTapJump(target) {
      target.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          if (currentView === "game" && isRunning) {
            tryJump();
          } else if (currentView === "gameOver" && !isRunning) {
            startGame();
          }
        },
        { passive: false }
      );
    }

    addTapJump(canvas);
    addTapJump(document.body);

    document.getElementById("btnPlay").addEventListener("click", () => {
      startGame();
    });

    document
      .getElementById("btnInstructions")
      .addEventListener("click", () => {
        stopMusic();
        showView("instructions");
      });

    document
      .getElementById("btnBackMenu")
      .addEventListener("click", () => {
        stopMusic();
        showView("menu");
      });

    document
      .getElementById("btnPlayFromInstructions")
      .addEventListener("click", () => {
        startGame();
      });

    document
      .getElementById("btnRestart")
      .addEventListener("click", () => {
        startGame();
      });

    document
      .getElementById("btnGoMenu")
      .addEventListener("click", () => {
        stopMusic();
        showView("menu");
      });
  </script>
</body>
</html>
