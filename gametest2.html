<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Andro Runner</title>
  <style>
    :root {
      --bg1: #050822;
      --bg2: #12052b;
      --primary: #00e5ff;
      --accent: #ff00ff;
      --accent2: #ffe066;
      --danger: #ff3366;
      --text: #f5f7ff;
      --muted: #9498c9;
      --lane-line: rgba(255, 255, 255, 0.1);
      --card-bg: rgba(7, 10, 30, 0.9);
      --border-radius: 14px;
      --transition-fast: 0.18s ease-out;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #29105a 0%, #050515 40%, #000208 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #app {
      width: 100%;
      max-width: 960px;
      padding: 16px;
    }

    .screen,
    .overlay {
      display: none;
    }

    .screen.active {
      display: flex;
    }

    .screen {
      flex-direction: column;
      gap: 16px;
      align-items: center;
      justify-content: center;
    }

    .card {
      background: var(--card-bg);
      border-radius: var(--border-radius);
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.65);
      padding: 20px;
      width: 100%;
      max-width: 480px;
      backdrop-filter: blur(18px);
    }

    h1 {
      font-size: clamp(2.1rem, 5vw, 3rem);
      text-align: center;
      margin-bottom: 16px;
      text-shadow: 0 0 18px rgba(0, 229, 255, 0.7),
        0 0 28px rgba(255, 0, 255, 0.7);
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    h2 {
      font-size: 1.2rem;
      margin-bottom: 12px;
    }

    p {
      font-size: 0.95rem;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .btn {
      width: 100%;
      padding: 10px 16px;
      margin-top: 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: radial-gradient(circle at top, #3f1fa1, #130922);
      color: var(--text);
      font-weight: 600;
      font-size: 0.98rem;
      cursor: pointer;
      transition: transform var(--transition-fast),
        box-shadow var(--transition-fast),
        background var(--transition-fast),
        border-color var(--transition-fast),
        opacity 0.12s;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 18px rgba(0, 229, 255, 0.5);
      border-color: rgba(0, 229, 255, 0.7);
    }

    .btn.secondary {
      background: radial-gradient(circle at top, #1f243a, #080914);
      border-color: rgba(255, 255, 255, 0.12);
    }

    .btn.danger {
      background: radial-gradient(circle at top, #5b1125, #170308);
      border-color: rgba(255, 51, 102, 0.7);
    }

    .btn.small {
      width: auto;
      padding-inline: 16px;
      font-size: 0.9rem;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-top: 12px;
    }

    .label-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 4px 0;
      font-size: 0.92rem;
    }

    select,
    input[type="range"] {
      width: 100%;
      margin-top: 4px;
      accent-color: var(--accent);
    }

    /* Game HUD / layout */

    #gameScreen {
      align-items: stretch;
    }

    .game-layout {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      max-width: 720px;
      margin-inline: auto;
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
    }

    .hud-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .hud-item-label {
      color: var(--muted);
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .hud-value {
      font-weight: 600;
    }

    .hearts {
      display: inline-flex;
      gap: 3px;
      font-size: 1rem;
      filter: drop-shadow(0 0 6px rgba(255, 102, 153, 0.7));
    }

    .hearts span {
      color: #ff6699;
    }

    .hud-card {
      background: var(--card-bg);
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 120px;
    }

    /* Game area */

    .game-area-wrapper {
      background: radial-gradient(circle at top, #251b6a 0%, #050515 60%, #000 100%);
      border-radius: 18px;
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow:
        0 0 25px rgba(0, 229, 255, 0.18),
        0 0 64px rgba(255, 0, 255, 0.12);
    }

    #gameArea {
      position: relative;
      width: 100%;
      max-width: 480px;
      margin: 0 auto;
      aspect-ratio: 9 / 16;
      overflow: hidden;
      border-radius: 16px;
      background-image: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.04) 1px,
          transparent 1px
        ),
        linear-gradient(
          to top,
          rgba(0, 0, 0, 0.6),
          rgba(0, 0, 0, 0.9)
        );
      background-size: 100% 18px, 100% 100%;
      animation: road-scroll 0.5s linear infinite;
      box-shadow:
        0 0 28px rgba(0, 0, 0, 0.8),
        0 0 50px rgba(0, 229, 255, 0.25);
    }

    @keyframes road-scroll {
      0% {
        background-position: 0 0, 0 0;
      }
      100% {
        background-position: 0 18px, 0 0;
      }
    }

    .lane-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background-image: linear-gradient(
        to bottom,
        var(--lane-line) 50%,
        transparent 50%
      );
      background-size: 2px 16px;
      left: calc(100% / 3);
    }

    .lane-line:nth-child(2) {
      left: calc(2 * (100% / 3));
    }

    .runner {
      position: absolute;
      width: 16%;
      height: 8%;
      border-radius: 10px;
      background: radial-gradient(circle at top, #00e5ff, #006c9c);
      box-shadow:
        0 0 18px rgba(0, 229, 255, 0.9),
        0 0 30px rgba(165, 31, 255, 0.7);
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0b1121;
      font-size: 0.7rem;
      font-weight: 700;
      text-shadow: none;
    }

    .runner::after {
      content: "▲";
      font-size: 0.8rem;
    }

    .obstacle {
      position: absolute;
      width: 18%;
      height: 10%;
      border-radius: 6px;
      background: radial-gradient(circle at top, #ff3366, #66031d);
      box-shadow:
        0 0 14px rgba(255, 51, 102, 0.9),
        0 0 28px rgba(255, 0, 153, 0.6);
      transform: translate(-50%, -50%);
    }

    .coin {
      position: absolute;
      width: 10%;
      height: 10%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 20%, #fffbe3, #ffd74a);
      box-shadow:
        0 0 10px rgba(255, 215, 74, 0.9),
        0 0 20px rgba(255, 215, 74, 0.7);
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      color: #623600;
      font-weight: 700;
      border: 2px solid rgba(255, 241, 180, 0.8);
    }

    .coin::after {
      content: "₿";
    }

    .coin.collected {
      animation: coin-pop 0.28s ease-out forwards;
    }

    @keyframes coin-pop {
      0% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(-50%, -120%) scale(1.5);
        opacity: 0;
      }
    }

    .hit-flash {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle, rgba(255, 51, 102, 0.5), transparent 60%);
      opacity: 0;
    }

    .hit-flash.active {
      animation: hit-blink 0.25s ease-out forwards;
    }

    @keyframes hit-blink {
      0% {
        opacity: 0.7;
      }
      100% {
        opacity: 0;
      }
    }

    /* Mobile controls */

    .mobile-controls {
      margin-top: 10px;
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .mobile-btn {
      flex: 1;
      max-width: 160px;
      padding: 12px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: radial-gradient(circle at top, #251f6a, #070818);
      color: var(--text);
      font-size: 1.05rem;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
        background 0.12s ease-out;
    }

    .mobile-btn:active {
      transform: scale(0.96) translateY(1px);
      box-shadow: 0 0 10px rgba(0, 229, 255, 0.6);
      background: radial-gradient(circle at bottom, #251f6a, #070818);
    }

    /* Modals & overlays */

    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(18px);
      background: radial-gradient(
        circle at top,
        rgba(0, 229, 255, 0.16),
        rgba(0, 0, 0, 0.9)
      );
      z-index: 50;
    }

    .overlay.hidden {
      display: none;
    }

    .modal {
      background: var(--card-bg);
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      padding: 16px 18px 14px;
      width: 100%;
      max-width: 420px;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.85);
      max-height: 90vh;
      overflow: auto;
    }

    .modal h2 {
      text-align: left;
    }

    .modal-close {
      text-align: right;
      margin-top: 8px;
    }

    .modal-close button {
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      font-size: 0.9rem;
    }

    .list {
      font-size: 0.9rem;
      color: var(--muted);
      padding-left: 18px;
      margin-bottom: 4px;
    }

    .list li {
      margin-bottom: 4px;
    }

    /* Score table */

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin-top: 6px;
    }

    th,
    td {
      padding: 4px 6px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    th {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    tbody tr:nth-child(odd) {
      background: rgba(255, 255, 255, 0.02);
    }

    .tag {
      display: inline-flex;
      padding: 1px 7px;
      border-radius: 999px;
      background: rgba(0, 229, 255, 0.12);
      border: 1px solid rgba(0, 229, 255, 0.4);
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .muted {
      color: var(--muted);
      font-size: 0.85rem;
    }

    @media (max-width: 600px) {
      .card {
        padding: 16px;
      }

      .hud-card {
        min-width: 48%;
      }

      .hud {
        gap: 6px;
      }

      .mobile-controls {
        margin-top: 8px;
      }
    }
  </style>
</head>
<body>
<div id="app">
  <!-- MENÚ PRINCIPAL -->
  <div id="mainMenu" class="screen active">
    <div class="card">
      <h1>Andro Runner</h1>
      <p class="muted" style="text-align:center;">
        Endless runner de 3 carriles con estilo neón futurista.
      </p>
      <button class="btn" id="btnPlay">Jugar</button>
      <button class="btn secondary" id="btnInstructions">Instrucciones</button>
      <button class="btn secondary" id="btnOptions">Opciones</button>
      <button class="btn secondary" id="btnScores">Ver tabla de puntuaciones</button>
    </div>
  </div>

  <!-- PANTALLA DE JUEGO -->
  <div id="gameScreen" class="screen">
    <div class="game-layout">
      <div class="hud">
        <div class="hud-group">
          <div class="hud-card">
            <span class="hud-item-label">Puntuación</span>
            <span id="scoreValue" class="hud-value">0</span>
          </div>
          <div class="hud-card">
            <span class="hud-item-label">Mejor</span>
            <span id="bestScoreValue" class="hud-value">0</span>
          </div>
        </div>
        <div class="hud-group">
          <div class="hud-card">
            <span class="hud-item-label">Dificultad</span>
            <span id="difficultyLabel" class="hud-value">Fácil</span>
          </div>
          <div class="hud-card">
            <span class="hud-item-label">Vidas</span>
            <span id="livesValue" class="hearts"></span>
          </div>
        </div>
      </div>

      <div class="game-area-wrapper">
        <div id="gameArea">
          <div class="lane-line"></div>
          <div class="lane-line"></div>
          <div id="hitFlash" class="hit-flash"></div>
        </div>
      </div>

      <div class="mobile-controls">
        <button class="mobile-btn" id="btnLeft">◀ Izquierda</button>
        <button class="mobile-btn" id="btnRight">Derecha ▶</button>
      </div>

      <div class="btn-row" style="justify-content:space-between;">
        <button class="btn small secondary" id="btnBackToMenuInGame">Volver al menú</button>
        <button class="btn small secondary" id="btnRestartInGame">Reiniciar</button>
      </div>
    </div>
  </div>

  <!-- PANTALLA TABLA DE PUNTUACIONES -->
  <div id="scoresScreen" class="screen">
    <div class="card">
      <h2>Tabla de puntuaciones</h2>
      <p class="muted">
        Se guardan las 5 mejores puntuaciones en este dispositivo.
      </p>
      <div id="scoresTableContainer"></div>
      <button class="btn secondary" id="btnBackFromScores">Volver al menú</button>
      <button class="btn danger" id="btnClearScores">Borrar puntuaciones</button>
    </div>
  </div>

  <!-- GAME OVER -->
  <div id="gameOverOverlay" class="overlay hidden">
    <div class="modal">
      <h2>Game Over</h2>
      <p>Puntuación obtenida: <strong id="finalScore"></strong></p>
      <p>Mejor puntuación histórica: <strong id="finalBestScore"></strong></p>
      <div class="btn-row">
        <button class="btn" id="btnPlayAgain">Jugar de nuevo</button>
        <button class="btn secondary" id="btnBackToMenuFromGameOver">Volver al menú</button>
      </div>
    </div>
  </div>

  <!-- MODAL INSTRUCCIONES -->
  <div id="instructionsOverlay" class="overlay hidden">
    <div class="modal">
      <h2>Instrucciones</h2>
      <p><strong>Objetivo:</strong> esquiva obstáculos, recoge monedas y consigue la máxima puntuación posible.</p>
      <ul class="list">
        <li>El personaje corre automáticamente hacia adelante.</li>
        <li>Hay 3 carriles: izquierda, centro y derecha.</li>
        <li>Los obstáculos restan vidas o terminan la partida según la dificultad.</li>
        <li>Las monedas dan puntos extra.</li>
      </ul>
      <p><strong>Controles en escritorio:</strong></p>
      <ul class="list">
        <li>Flecha izquierda / tecla A: mover al carril de la izquierda.</li>
        <li>Flecha derecha / tecla D: mover al carril de la derecha.</li>
      </ul>
      <p><strong>Controles en móvil:</strong></p>
      <ul class="list">
        <li>Botones grandes “Izquierda” y “Derecha” debajo del juego.</li>
      </ul>
      <div class="modal-close">
        <button id="btnCloseInstructions">Cerrar</button>
      </div>
    </div>
  </div>

  <!-- MODAL OPCIONES -->
  <div id="optionsOverlay" class="overlay hidden">
    <div class="modal">
      <h2>Opciones</h2>
      <div class="label-row">
        <span>Dificultad</span>
        <span class="tag" id="currentDifficultyTag">Fácil</span>
      </div>
      <select id="difficultySelect">
        <option value="easy">Fácil (3 vidas, velocidad baja)</option>
        <option value="normal">Normal (2 vidas, velocidad media)</option>
        <option value="hard">Difícil (1 vida, velocidad alta)</option>
      </select>

      <div class="label-row" style="margin-top:10px;">
        <span>Volumen</span>
        <span class="muted" id="volumeLabel">50%</span>
      </div>
      <input type="range" id="volumeRange" min="0" max="100" value="50" />

      <p class="muted" style="margin-top:10px;">
        La dificultad afecta la velocidad, número de vidas, y la frecuencia de aparición de obstáculos y monedas.
      </p>

      <div class="modal-close">
        <button id="btnCloseOptions">Cerrar</button>
      </div>
    </div>
  </div>
</div>

<script>
  // =========================
  // CONFIGURACIÓN GENERAL
  // =========================

  const difficultySettings = {
    easy: {
      name: "Fácil",
      baseSpeed: 0.16,       // velocidad base (distancia/ ms)
      speedIncrease: 0.00003,
      obstacleInterval: 950, // ms entre obstáculos
      coinInterval: 650,     // ms entre monedas
      lives: 3
    },
    normal: {
      name: "Normal",
      baseSpeed: 0.21,
      speedIncrease: 0.000045,
      obstacleInterval: 750,
      coinInterval: 750,
      lives: 2
    },
    hard: {
      name: "Difícil",
      baseSpeed: 0.27,
      speedIncrease: 0.000065,
      obstacleInterval: 580,
      coinInterval: 900,
      lives: 1
    }
  };

  const LANE_CENTERS = [16.66, 50, 83.33]; // porcentaje horizontal del centro de cada carril
  const PLAYER_Y = 82; // porcentaje vertical
  const GAME_HEIGHT = 100;

  let currentDifficultyKey = "easy";
  let currentSettings = difficultySettings[currentDifficultyKey];

  // Estado del juego
  let animationId = null;
  let running = false;
  let lastTimestamp = null;

  let playerLane = 1;
  let obstacles = [];
  let coins = [];

  let score = 0;
  let bestScore = 0;
  let distance = 0;
  let lives = currentSettings.lives;
  let speed = currentSettings.baseSpeed;
  let obstacleTimer = 0;
  let coinTimer = 0;
  let coinsCollected = 0;

  const MAX_SCORES = 5;
  const SCORE_STORAGE_KEY = "androRunnerScores";
  const BEST_SCORE_KEY = "androRunnerBestScore";

  // =========================
  // REFERENCIAS DOM
  // =========================

  const mainMenu = document.getElementById("mainMenu");
  const gameScreen = document.getElementById("gameScreen");
  const scoresScreen = document.getElementById("scoresScreen");

  const btnPlay = document.getElementById("btnPlay");
  const btnInstructions = document.getElementById("btnInstructions");
  const btnOptions = document.getElementById("btnOptions");
  const btnScores = document.getElementById("btnScores");
  const btnBackFromScores = document.getElementById("btnBackFromScores");
  const btnClearScores = document.getElementById("btnClearScores");

  const btnBackToMenuInGame = document.getElementById("btnBackToMenuInGame");
  const btnRestartInGame = document.getElementById("btnRestartInGame");

  const gameArea = document.getElementById("gameArea");
  const hitFlash = document.getElementById("hitFlash");

  const scoreValue = document.getElementById("scoreValue");
  const bestScoreValue = document.getElementById("bestScoreValue");
  const difficultyLabel = document.getElementById("difficultyLabel");
  const livesValue = document.getElementById("livesValue");

  const gameOverOverlay = document.getElementById("gameOverOverlay");
  const finalScoreEl = document.getElementById("finalScore");
  const finalBestScoreEl = document.getElementById("finalBestScore");
  const btnPlayAgain = document.getElementById("btnPlayAgain");
  const btnBackToMenuFromGameOver = document.getElementById("btnBackToMenuFromGameOver");

  const instructionsOverlay = document.getElementById("instructionsOverlay");
  const btnCloseInstructions = document.getElementById("btnCloseInstructions");

  const optionsOverlay = document.getElementById("optionsOverlay");
  const difficultySelect = document.getElementById("difficultySelect");
  const currentDifficultyTag = document.getElementById("currentDifficultyTag");
  const btnCloseOptions = document.getElementById("btnCloseOptions");
  const volumeRange = document.getElementById("volumeRange");
  const volumeLabel = document.getElementById("volumeLabel");

  const btnLeft = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");

  const scoresTableContainer = document.getElementById("scoresTableContainer");

  // =========================
  // UTILIDADES
  // =========================

  function setScreen(screenName) {
    mainMenu.classList.remove("active");
    gameScreen.classList.remove("active");
    scoresScreen.classList.remove("active");

    if (screenName === "menu") {
      mainMenu.classList.add("active");
    } else if (screenName === "game") {
      gameScreen.classList.add("active");
    } else if (screenName === "scores") {
      scoresScreen.classList.add("active");
    }
  }

  function showOverlay(overlay) {
    overlay.classList.remove("hidden");
  }

  function hideOverlay(overlay) {
    overlay.classList.add("hidden");
  }

  function updateHUD() {
    scoreValue.textContent = Math.floor(score);
    bestScoreValue.textContent = Math.floor(bestScore);
    difficultyLabel.textContent = currentSettings.name;

    livesValue.innerHTML = "";
    for (let i = 0; i < lives; i++) {
      const span = document.createElement("span");
      span.textContent = "❤";
      livesValue.appendChild(span);
    }
  }

  function loadScores() {
    try {
      const stored = localStorage.getItem(SCORE_STORAGE_KEY);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (e) {
      console.warn("No se pudieron cargar puntuaciones:", e);
    }
    return [];
  }

  function saveScores(scores) {
    try {
      localStorage.setItem(SCORE_STORAGE_KEY, JSON.stringify(scores));
    } catch (e) {
      console.warn("No se pudieron guardar puntuaciones:", e);
    }
  }

  function loadBestScore() {
    const scores = loadScores();
    let best = 0;
    scores.forEach(s => {
      if (s.score > best) best = s.score;
    });

    try {
      const storedBest = localStorage.getItem(BEST_SCORE_KEY);
      if (storedBest !== null) {
        best = Math.max(best, parseInt(storedBest, 10) || 0);
      }
    } catch (e) {}

    bestScore = best;
  }

  function persistBestScore() {
    try {
      localStorage.setItem(BEST_SCORE_KEY, String(Math.floor(bestScore)));
    } catch (e) {}
  }

  function addScoreToTable(scoreValueNum) {
    const scores = loadScores();
    const record = {
      score: Math.floor(scoreValueNum),
      difficulty: currentSettings.name,
      date: new Date().toLocaleString()
    };
    scores.push(record);
    scores.sort((a, b) => b.score - a.score);
    const trimmed = scores.slice(0, MAX_SCORES);
    saveScores(trimmed);

    if (record.score > bestScore) {
      bestScore = record.score;
      persistBestScore();
    }
  }

  function renderScoreTable() {
    const scores = loadScores();
    if (!scores.length) {
      scoresTableContainer.innerHTML = "<p class='muted'>Todavía no hay puntuaciones.</p>";
      return;
    }

    let html = "<table><thead><tr><th>#</th><th>Puntos</th><th>Dificultad</th><th>Fecha</th></tr></thead><tbody>";
    scores.forEach((s, i) => {
      html += `<tr>
        <td>${i + 1}</td>
        <td>${s.score}</td>
        <td>${s.difficulty}</td>
        <td>${s.date}</td>
      </tr>`;
    });
    html += "</tbody></table>";
    scoresTableContainer.innerHTML = html;
  }

  function clearEntities() {
    obstacles.forEach(o => {
      if (o.el && o.el.parentNode) {
        o.el.parentNode.removeChild(o.el);
      }
    });
    coins.forEach(c => {
      if (c.el && c.el.parentNode) {
        c.el.parentNode.removeChild(c.el);
      }
    });
    obstacles = [];
    coins = [];
  }

  // =========================
  // ENTIDADES
  // =========================

  let playerEl = null;

  function createPlayer() {
    if (playerEl && playerEl.parentNode) {
      playerEl.parentNode.removeChild(playerEl);
    }
    playerEl = document.createElement("div");
    playerEl.className = "runner";
    gameArea.appendChild(playerEl);
    updatePlayerPosition();
  }

  function updatePlayerPosition() {
    if (!playerEl) return;
    const x = LANE_CENTERS[playerLane];
    const y = PLAYER_Y;
    playerEl.style.left = x + "%";
    playerEl.style.top = y + "%";
  }

  function spawnObstacle() {
    const lane = Math.floor(Math.random() * 3);
    const el = document.createElement("div");
    el.className = "obstacle";
    gameArea.appendChild(el);

    const obj = {
      lane,
      y: -10,
      el
    };
    obstacles.push(obj);
    positionEntity(obj);
  }

  function spawnCoin() {
    const lane = Math.floor(Math.random() * 3);
    const el = document.createElement("div");
    el.className = "coin";
    gameArea.appendChild(el);

    const obj = {
      lane,
      y: -10,
      el,
      collected: false
    };
    coins.push(obj);
    positionEntity(obj);
  }

  function positionEntity(entity) {
    const x = LANE_CENTERS[entity.lane];
    const y = entity.y;
    entity.el.style.left = x + "%";
    entity.el.style.top = y + "%";
  }

  function removeEntityFromArray(arr, index) {
    const entity = arr[index];
    if (entity && entity.el && entity.el.parentNode) {
      entity.el.parentNode.removeChild(entity.el);
    }
    arr.splice(index, 1);
  }

  // =========================
  // LÓGICA DE JUEGO
  // =========================

  function resetGameState() {
    clearEntities();
    playerLane = 1;
    createPlayer();

    currentSettings = difficultySettings[currentDifficultyKey];
    lives = currentSettings.lives;
    speed = currentSettings.baseSpeed;
    distance = 0;
    score = 0;
    coinsCollected = 0;
    obstacleTimer = 0;
    coinTimer = 0;
    lastTimestamp = null;
    running = false;

    loadBestScore();
    updateHUD();
  }

  function startGame() {
    resetGameState();
    setScreen("game");
    running = true;
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
    animationId = requestAnimationFrame(gameLoop);
  }

  function endGame() {
    running = false;
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
    addScoreToTable(score);
    loadBestScore();
    updateHUD();

    finalScoreEl.textContent = Math.floor(score);
    finalBestScoreEl.textContent = Math.floor(bestScore);
    showOverlay(gameOverOverlay);
  }

  function hitObstacle() {
    if (lives > 0) {
      lives -= 1;
      hitFlash.classList.remove("active");
      void hitFlash.offsetWidth;
      hitFlash.classList.add("active");
      if (lives <= 0) {
        endGame();
      }
    }
    updateHUD();
  }

  function collectCoin(coinObj, index) {
    if (coinObj.collected) return;
    coinObj.collected = true;
    coinsCollected += 1;
    score += 120;

    coinObj.el.classList.add("collected");
    setTimeout(() => {
      if (coinObj.el && coinObj.el.parentNode) {
        coinObj.el.parentNode.removeChild(coinObj.el);
      }
    }, 260);
    coins.splice(index, 1);
    updateHUD();
  }

  function gameLoop(timestamp) {
    if (!running) return;
    if (!lastTimestamp) lastTimestamp = timestamp;
    const delta = timestamp - lastTimestamp;
    lastTimestamp = timestamp;

    const deltaSeconds = delta / 1000;

    // Distancia y velocidad
    distance += speed * delta;
    speed += currentSettings.speedIncrease * delta;

    // Puntuación base por distancia
    score += deltaSeconds * (2 + speed * 5);
    if (score > bestScore) {
      bestScore = score;
    }

    // Spawns
    obstacleTimer += delta;
    if (obstacleTimer >= currentSettings.obstacleInterval) {
      obstacleTimer = 0;
      spawnObstacle();
    }
    coinTimer += delta;
    if (coinTimer >= currentSettings.coinInterval) {
      coinTimer = 0;
      // Menos monedas en difícil
      if (currentDifficultyKey === "hard") {
        if (Math.random() < 0.6) spawnCoin();
      } else if (currentDifficultyKey === "normal") {
        if (Math.random() < 0.8) spawnCoin();
      } else {
        spawnCoin();
      }
    }

    // Mover entidades
    const speedFactor = speed * 0.06;
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obj = obstacles[i];
      obj.y += speedFactor * delta;
      if (obj.y > GAME_HEIGHT + 20) {
        removeEntityFromArray(obstacles, i);
        continue;
      }
      positionEntity(obj);

      // Colisión con jugador
      if (Math.abs(obj.y - PLAYER_Y) < 6 && obj.lane === playerLane) {
        removeEntityFromArray(obstacles, i);
        hitObstacle();
        if (!running) {
          updateHUD();
          return;
        }
      }
    }

    for (let i = coins.length - 1; i >= 0; i--) {
      const c = coins[i];
      c.y += speedFactor * delta;
      if (c.y > GAME_HEIGHT + 20) {
        removeEntityFromArray(coins, i);
        continue;
      }
      positionEntity(c);

      if (Math.abs(c.y - PLAYER_Y) < 8 && c.lane === playerLane) {
        collectCoin(c, i);
      }
    }

    updateHUD();
    animationId = requestAnimationFrame(gameLoop);
  }

  // =========================
  // INPUT / CONTROLES
  // =========================

  function moveLeft() {
    if (!running) return;
    if (playerLane > 0) {
      playerLane -= 1;
      updatePlayerPosition();
    }
  }

  function moveRight() {
    if (!running) return;
    if (playerLane < 2) {
      playerLane += 1;
      updatePlayerPosition();
    }
  }

  function handleKeyDown(e) {
    if (!gameScreen.classList.contains("active")) return;
    const key = e.key.toLowerCase();
    if (key === "arrowleft" || key === "a") {
      e.preventDefault();
      moveLeft();
    } else if (key === "arrowright" || key === "d") {
      e.preventDefault();
      moveRight();
    }
  }

  // =========================
  // EVENTOS DE INTERFAZ
  // =========================

  btnPlay.addEventListener("click", () => {
    startGame();
  });

  btnInstructions.addEventListener("click", () => {
    showOverlay(instructionsOverlay);
  });

  btnCloseInstructions.addEventListener("click", () => {
    hideOverlay(instructionsOverlay);
  });

  btnOptions.addEventListener("click", () => {
    difficultySelect.value = currentDifficultyKey;
    currentDifficultyTag.textContent = currentSettings.name;
    showOverlay(optionsOverlay);
  });

  btnCloseOptions.addEventListener("click", () => {
    hideOverlay(optionsOverlay);
  });

  btnScores.addEventListener("click", () => {
    renderScoreTable();
    setScreen("scores");
  });

  btnBackFromScores.addEventListener("click", () => {
    setScreen("menu");
  });

  btnClearScores.addEventListener("click", () => {
    if (confirm("¿Seguro que quieres borrar todas las puntuaciones?")) {
      localStorage.removeItem(SCORE_STORAGE_KEY);
      localStorage.removeItem(BEST_SCORE_KEY);
      bestScore = 0;
      renderScoreTable();
      updateHUD();
    }
  });

  btnBackToMenuInGame.addEventListener("click", () => {
    running = false;
    if (animationId) cancelAnimationFrame(animationId);
    setScreen("menu");
  });

  btnRestartInGame.addEventListener("click", () => {
    startGame();
  });

  btnPlayAgain.addEventListener("click", () => {
    hideOverlay(gameOverOverlay);
    startGame();
  });

  btnBackToMenuFromGameOver.addEventListener("click", () => {
    hideOverlay(gameOverOverlay);
    setScreen("menu");
  });

  btnLeft.addEventListener("click", moveLeft);
  btnRight.addEventListener("click", moveRight);

  // Touch "hold" soporte sencillo
  let leftTouchInterval = null;
  let rightTouchInterval = null;

  function startHoldLeft() {
    if (leftTouchInterval) return;
    moveLeft();
    leftTouchInterval = setInterval(moveLeft, 130);
  }
  function endHoldLeft() {
    clearInterval(leftTouchInterval);
    leftTouchInterval = null;
  }
  function startHoldRight() {
    if (rightTouchInterval) return;
    moveRight();
    rightTouchInterval = setInterval(moveRight, 130);
  }
  function endHoldRight() {
    clearInterval(rightTouchInterval);
    rightTouchInterval = null;
  }

  ["touchstart"].forEach(ev => {
    btnLeft.addEventListener(ev, e => {
      e.preventDefault();
      startHoldLeft();
    });
    btnRight.addEventListener(ev, e => {
      e.preventDefault();
      startHoldRight();
    });
  });

  ["touchend", "touchcancel"].forEach(ev => {
    btnLeft.addEventListener(ev, e => {
      e.preventDefault();
      endHoldLeft();
    });
    btnRight.addEventListener(ev, e => {
      e.preventDefault();
      endHoldRight();
    });
  });

  difficultySelect.addEventListener("change", e => {
    currentDifficultyKey = e.target.value;
    currentSettings = difficultySettings[currentDifficultyKey];
    currentDifficultyTag.textContent = currentSettings.name;
  });

  volumeRange.addEventListener("input", e => {
    const value = Number(e.target.value);
    volumeLabel.textContent = value + "%";
    // Aquí podrías conectar el volumen a sonidos si los añades.
  });

  document.addEventListener("keydown", handleKeyDown);

  // =========================
  // INICIALIZACIÓN
  // =========================

  function init() {
    loadBestScore();
    resetGameState();
    setScreen("menu");
  }

  init();
</script>
</body>
</html>
